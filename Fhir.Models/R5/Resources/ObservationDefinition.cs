// Auto-generated for FHIR R5
using System.ComponentModel.DataAnnotations;

namespace Fhir.R5.Models;

/// <summary>
/// Set of definitional characteristics for a kind of observation or measurement produced or consumed by
/// an orderable health care service.
/// </summary>
public class ObservationDefinition : DomainResource
{
    public override string ResourceType => "ObservationDefinition";

    /// <summary>
    /// The logical id of the resource, as used in the URL for the resource. Once assigned, this value never
    /// changes.
    /// </summary>
    [FhirElement("id", Order = 10)]
    [Cardinality(0, 1)]
    [JsonPropertyName("id")]
    public FhirString? Id { get; set; }

    /// <summary>
    /// The metadata about the resource. This is content that is maintained by the infrastructure. Changes
    /// to the content might not always be associated with version changes to the resource.
    /// </summary>
    [FhirElement("meta", Order = 11)]
    [Cardinality(0, 1)]
    [JsonPropertyName("meta")]
    public Meta Meta { get; set; }

    /// <summary>
    /// A reference to a set of rules that were followed when the resource was constructed, and which must
    /// be understood when processing the content. Often, this is a reference to an implementation guide
    /// that defines the special rules along with other profiles etc.
    /// </summary>
    [FhirElement("implicitRules", Order = 12)]
    [Cardinality(0, 1)]
    [JsonPropertyName("implicitRules")]
    public FhirUri? ImplicitRules { get; set; }

    /// <summary>
    /// The base language in which the resource is written.
    /// </summary>
    [FhirElement("language", Order = 13)]
    [Cardinality(0, 1)]
    [JsonPropertyName("language")]
    public FhirCode? Language { get; set; }

    /// <summary>
    /// A human-readable narrative that contains a summary of the resource and can be used to represent the
    /// content of the resource to a human. The narrative need not encode all the structured data, but is
    /// required to contain sufficient detail to make it &quot;clinically safe&quot; for a human to just
    /// read the narrative. Resource definitions may define what content should be represented in the
    /// narrative to ensure clinical safety.
    /// </summary>
    [FhirElement("text", Order = 14)]
    [Cardinality(0, 1)]
    [JsonPropertyName("text")]
    public Narrative Text { get; set; }

    /// <summary>
    /// These resources do not have an independent existence apart from the resource that contains them -
    /// they cannot be identified independently, nor can they have their own independent transaction scope.
    /// This is allowed to be a Parameters resource if and only if it is referenced by a resource that
    /// provides context/meaning.
    /// </summary>
    [FhirElement("contained", Order = 15)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("contained")]
    public List<Resource>? Contained { get; set; }

    /// <summary>
    /// May be used to represent additional information that is not part of the basic definition of the
    /// resource. To make the use of extensions safe and managable, there is a strict set of governance
    /// applied to the definition and use of extensions. Though any implementer can define an extension,
    /// there is a set of requirements that SHALL be met as part of the definition of the extension.
    /// </summary>
    [FhirElement("extension", Order = 16)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("extension")]
    public List<Extension>? Extension { get; set; }

    /// <summary>
    /// May be used to represent additional information that is not part of the basic definition of the
    /// resource and that modifies the understanding of the element that contains it and/or the
    /// understanding of the containing element&apos;s descendants. Usually modifier elements provide
    /// negation or qualification. To make the use of extensions safe and managable, there is a strict set
    /// of governance applied to the definition and use of extensions. Though any implementer is allowed to
    /// define an extension, there is a set of requirements that SHALL be met as part of the definition of
    /// the extension. Applications processing a resource are required to check for modifier extensions.
    /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
    /// (including cannot change the meaning of modifierExtension itself).
    /// </summary>
    [FhirElement("modifierExtension", Order = 17)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("modifierExtension")]
    public List<Extension>? ModifierExtension { get; set; }

    /// <summary>
    /// An absolute URL that is used to identify this ObservationDefinition when it is referenced in a
    /// specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and
    /// SHOULD be an address at which this ObservationDefinition is (or will be) published. The URL SHOULD
    /// include the major version of the ObservationDefinition. For more information see Technical and
    /// Business Versions.
    /// </summary>
    [FhirElement("url", Order = 18)]
    [Cardinality(0, 1)]
    [JsonPropertyName("url")]
    public FhirUri? Url { get; set; }

    /// <summary>
    /// Business identifiers assigned to this ObservationDefinition. by the performer and/or other systems.
    /// These identifiers remain constant as the resource is updated and propagates from server to server.
    /// </summary>
    [FhirElement("identifier", Order = 19)]
    [Cardinality(0, 1)]
    [JsonPropertyName("identifier")]
    public Identifier Identifier { get; set; }

    /// <summary>
    /// The identifier that is used to identify this version of the ObservationDefinition when it is
    /// referenced in a specification, model, design or instance. This is an arbitrary value managed by the
    /// ObservationDefinition author and is not expected to be globally unique. For example, it might be a
    /// timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that
    /// versions are orderable.
    /// </summary>
    [FhirElement("version", Order = 20)]
    [Cardinality(0, 1)]
    [JsonPropertyName("version")]
    public FhirString? Version { get; set; }

    /// <summary>
    /// Indicates the mechanism used to compare versions to determine which is more current. (as string)
    /// </summary>
    [FhirElement("versionAlgorithmString", Order = 21)]
    [Cardinality(0, 1)]
    [ChoiceType("versionAlgorithm", "string")]
    [JsonPropertyName("versionAlgorithmString")]
    public FhirString? VersionAlgorithmString { get; set; }

    /// <summary>
    /// Indicates the mechanism used to compare versions to determine which is more current. (as Coding)
    /// </summary>
    [FhirElement("versionAlgorithmCoding", Order = 22)]
    [Cardinality(0, 1)]
    [ChoiceType("versionAlgorithm", "coding")]
    [JsonPropertyName("versionAlgorithmCoding")]
    public Coding VersionAlgorithmCoding { get; set; }

    /// <summary>
    /// A natural language name identifying the ObservationDefinition. This name should be usable as an
    /// identifier for the module by machine processing applications such as code generation.
    /// </summary>
    [FhirElement("name", Order = 23)]
    [Cardinality(0, 1)]
    [JsonPropertyName("name")]
    public FhirString? Name { get; set; }

    /// <summary>
    /// A short, descriptive, user-friendly title for the ObservationDefinition.
    /// </summary>
    [FhirElement("title", Order = 24)]
    [Cardinality(0, 1)]
    [JsonPropertyName("title")]
    public FhirString? Title { get; set; }

    /// <summary>
    /// The current state of the ObservationDefinition.
    /// </summary>
    [FhirElement("status", Order = 25)]
    [Cardinality(1, 1)]
    [Required]
    [JsonPropertyName("status")]
    public FhirCode Status { get; set; }

    /// <summary>
    /// A flag to indicate that this ObservationDefinition is authored for testing purposes (or
    /// education/evaluation/marketing), and is not intended to be used for genuine usage.
    /// </summary>
    [FhirElement("experimental", Order = 26)]
    [Cardinality(0, 1)]
    [JsonPropertyName("experimental")]
    public FhirBoolean? Experimental { get; set; }

    /// <summary>
    /// The date (and optionally time) when the ObservationDefinition was last significantly changed. The
    /// date must change when the business version changes and it must change if the status code changes. In
    /// addition, it should change when the substantive content of the ObservationDefinition changes.
    /// </summary>
    [FhirElement("date", Order = 27)]
    [Cardinality(0, 1)]
    [JsonPropertyName("date")]
    public FhirDateTime? Date { get; set; }

    /// <summary>
    /// Helps establish the &quot;authority/credibility&quot; of the ObservationDefinition. May also allow
    /// for contact.
    /// </summary>
    [FhirElement("publisher", Order = 28)]
    [Cardinality(0, 1)]
    [JsonPropertyName("publisher")]
    public FhirString? Publisher { get; set; }

    /// <summary>
    /// Contact details to assist a user in finding and communicating with the publisher.
    /// </summary>
    [FhirElement("contact", Order = 29)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("contact")]
    public List<ContactDetail>? Contact { get; set; }

    /// <summary>
    /// A free text natural language description of the ObservationDefinition from the consumer&apos;s
    /// perspective.
    /// </summary>
    [FhirElement("description", Order = 30)]
    [Cardinality(0, 1)]
    [JsonPropertyName("description")]
    public FhirMarkdown? Description { get; set; }

    /// <summary>
    /// The content was developed with a focus and intent of supporting the contexts that are listed. These
    /// contexts may be general categories (gender, age, ...) or may be references to specific programs
    /// (insurance plans, studies, ...) and may be used to assist with indexing and searching for
    /// appropriate ObservationDefinition instances.
    /// </summary>
    [FhirElement("useContext", Order = 31)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("useContext")]
    public List<UsageContext>? UseContext { get; set; }

    /// <summary>
    /// A jurisdiction in which the ObservationDefinition is intended to be used.
    /// </summary>
    [FhirElement("jurisdiction", Order = 32)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("jurisdiction")]
    public List<CodeableConcept>? Jurisdiction { get; set; }

    /// <summary>
    /// Explains why this ObservationDefinition is needed and why it has been designed as it has.
    /// </summary>
    [FhirElement("purpose", Order = 33)]
    [Cardinality(0, 1)]
    [JsonPropertyName("purpose")]
    public FhirMarkdown? Purpose { get; set; }

    /// <summary>
    /// Copyright statement relating to the ObservationDefinition and/or its contents. Copyright statements
    /// are generally legal restrictions on the use and publishing of the ObservationDefinition.
    /// </summary>
    [FhirElement("copyright", Order = 34)]
    [Cardinality(0, 1)]
    [JsonPropertyName("copyright")]
    public FhirMarkdown? Copyright { get; set; }

    /// <summary>
    /// A short string (&lt;50 characters), suitable for inclusion in a page footer that identifies the
    /// copyright holder, effective period, and optionally whether rights are resctricted. (e.g. &apos;All
    /// rights reserved&apos;, &apos;Some rights reserved&apos;).
    /// </summary>
    [FhirElement("copyrightLabel", Order = 35)]
    [Cardinality(0, 1)]
    [JsonPropertyName("copyrightLabel")]
    public FhirString? CopyrightLabel { get; set; }

    /// <summary>
    /// The date on which the asset content was approved by the publisher. Approval happens once when the
    /// content is officially approved for usage.
    /// </summary>
    [FhirElement("approvalDate", Order = 36)]
    [Cardinality(0, 1)]
    [JsonPropertyName("approvalDate")]
    public FhirDate? ApprovalDate { get; set; }

    /// <summary>
    /// The date on which the asset content was last reviewed. Review happens periodically after that, but
    /// doesn&apos;t change the original approval date.
    /// </summary>
    [FhirElement("lastReviewDate", Order = 37)]
    [Cardinality(0, 1)]
    [JsonPropertyName("lastReviewDate")]
    public FhirDate? LastReviewDate { get; set; }

    /// <summary>
    /// The period during which the ObservationDefinition content was or is planned to be effective.
    /// </summary>
    [FhirElement("effectivePeriod", Order = 38)]
    [Cardinality(0, 1)]
    [JsonPropertyName("effectivePeriod")]
    public Period EffectivePeriod { get; set; }

    /// <summary>
    /// The canonical URL pointing to another FHIR-defined ObservationDefinition that is adhered to in whole
    /// or in part by this definition.
    /// </summary>
    [FhirElement("derivedFromCanonical", Order = 39)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("derivedFromCanonical")]
    public List<FhirCanonical>? DerivedFromCanonical { get; set; }

    /// <summary>
    /// The URL pointing to an externally-defined observation definition, guideline or other definition that
    /// is adhered to in whole or in part by this definition.
    /// </summary>
    [FhirElement("derivedFromUri", Order = 40)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("derivedFromUri")]
    public List<FhirUri>? DerivedFromUri { get; set; }

    /// <summary>
    /// A code that describes the intended kind of subject of Observation instances conforming to this
    /// ObservationDefinition.
    /// </summary>
    [FhirElement("subject", Order = 41)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("subject")]
    public List<CodeableConcept>? Subject { get; set; }

    /// <summary>
    /// The type of individual/organization/device that is expected to act upon instances of this
    /// definition.
    /// </summary>
    [FhirElement("performerType", Order = 42)]
    [Cardinality(0, 1)]
    [JsonPropertyName("performerType")]
    public CodeableConcept PerformerType { get; set; }

    /// <summary>
    /// A code that classifies the general type of observation.
    /// </summary>
    [FhirElement("category", Order = 43)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("category")]
    public List<CodeableConcept>? Category { get; set; }

    /// <summary>
    /// Describes what will be observed. Sometimes this is called the observation &quot;name&quot;.
    /// </summary>
    [FhirElement("code", Order = 44)]
    [Cardinality(1, 1)]
    [Required]
    [JsonPropertyName("code")]
    public CodeableConcept Code { get; set; }

    /// <summary>
    /// The data types allowed for the value element of the instance observations conforming to this
    /// ObservationDefinition.
    /// </summary>
    [FhirElement("permittedDataType", Order = 45)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("permittedDataType")]
    public List<FhirCode>? PermittedDataType { get; set; }

    /// <summary>
    /// Multiple results allowed for observations conforming to this ObservationDefinition.
    /// </summary>
    [FhirElement("multipleResultsAllowed", Order = 46)]
    [Cardinality(0, 1)]
    [JsonPropertyName("multipleResultsAllowed")]
    public FhirBoolean? MultipleResultsAllowed { get; set; }

    /// <summary>
    /// The site on the subject&apos;s body where the observation is to be made.
    /// </summary>
    [FhirElement("bodySite", Order = 47)]
    [Cardinality(0, 1)]
    [JsonPropertyName("bodySite")]
    public CodeableConcept BodySite { get; set; }

    /// <summary>
    /// The method or technique used to perform the observation.
    /// </summary>
    [FhirElement("method", Order = 48)]
    [Cardinality(0, 1)]
    [JsonPropertyName("method")]
    public CodeableConcept Method { get; set; }

    /// <summary>
    /// The kind of specimen that this type of observation is produced on.
    /// </summary>
    [FhirElement("specimen", Order = 49)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("specimen")]
    public List<Reference<SpecimenDefinition>>? Specimen { get; set; }

    /// <summary>
    /// The measurement model of device or actual device used to produce observations of this type.
    /// </summary>
    [FhirElement("device", Order = 50)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("device")]
    public List<Reference<DeviceDefinition>>? Device { get; set; }

    /// <summary>
    /// The preferred name to be used when reporting the results of observations conforming to this
    /// ObservationDefinition.
    /// </summary>
    [FhirElement("preferredReportName", Order = 51)]
    [Cardinality(0, 1)]
    [JsonPropertyName("preferredReportName")]
    public FhirString? PreferredReportName { get; set; }

    /// <summary>
    /// Units allowed for the valueQuantity element in the instance observations conforming to this
    /// ObservationDefinition.
    /// </summary>
    [FhirElement("permittedUnit", Order = 52)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("permittedUnit")]
    public List<Coding>? PermittedUnit { get; set; }

    /// <summary>
    /// A set of qualified values associated with a context and a set of conditions - provides a range for
    /// quantitative and ordinal observations and a collection of value sets for qualitative observations.
    /// </summary>
    [FhirElement("qualifiedValue", Order = 53)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("qualifiedValue")]
    public List<BackboneElement>? QualifiedValue { get; set; }

    /// <summary>
    /// This ObservationDefinition defines a group observation (e.g. a battery, a panel of tests, a set of
    /// vital sign measurements) that includes the target as a member of the group.
    /// </summary>
    [FhirElement("hasMember", Order = 54)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("hasMember")]
    public List<Reference<ObservationDefinition>>? HasMember { get; set; }

    /// <summary>
    /// Some observations have multiple component observations, expressed as separate code value pairs.
    /// </summary>
    [FhirElement("component", Order = 55)]
    [Cardinality(0, int.MaxValue)]
    [JsonPropertyName("component")]
    public List<BackboneElement>? Component { get; set; }

    /// <summary>
    /// Validates choice type constraints
    /// </summary>
    public override IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        foreach (var result in base.Validate(validationContext))
            yield return result;

        // Choice Type validation for versionAlgorithm[x]
        var versionAlgorithmProperties = new[] { nameof(VersionAlgorithmString), nameof(VersionAlgorithmCoding) };
        var versionAlgorithmSetCount = versionAlgorithmProperties.Count(prop => 
            GetType().GetProperty(prop)?.GetValue(this) != null);

        if (versionAlgorithmSetCount > 1)
        {
            yield return new ValidationResult(
                "Only one of VersionAlgorithmString, VersionAlgorithmCoding may be specified",
                new[] { nameof(VersionAlgorithmString), nameof(VersionAlgorithmCoding) });
        }

    }


    /// <summary>
    /// Validates this instance according to FHIR rules
    /// </summary>
    public override IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        foreach (var result in base.Validate(validationContext))
            yield return result;

        // Cardinality validation
        // Validate ObservationDefinition cardinality
        var observationdefinitionCount = ObservationDefinition?.Count ?? 0;
        if (observationdefinitionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition' cardinality must be 0..*", new[] { nameof(ObservationDefinition) });
        }
        // Validate Contained cardinality
        var containedCount = Contained?.Count ?? 0;
        if (containedCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.contained' cardinality must be 0..*", new[] { nameof(Contained) });
        }
        // Validate Extension cardinality
        var extensionCount = Extension?.Count ?? 0;
        if (extensionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.extension' cardinality must be 0..*", new[] { nameof(Extension) });
        }
        // Validate ModifierExtension cardinality
        var modifierextensionCount = ModifierExtension?.Count ?? 0;
        if (modifierextensionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.modifierExtension' cardinality must be 0..*", new[] { nameof(ModifierExtension) });
        }
        if (Status == null)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.status' cardinality must be 1..1", new[] { nameof(Status) });
        }
        // Validate Contact cardinality
        var contactCount = Contact?.Count ?? 0;
        if (contactCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.contact' cardinality must be 0..*", new[] { nameof(Contact) });
        }
        // Validate UseContext cardinality
        var usecontextCount = UseContext?.Count ?? 0;
        if (usecontextCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.useContext' cardinality must be 0..*", new[] { nameof(UseContext) });
        }
        // Validate Jurisdiction cardinality
        var jurisdictionCount = Jurisdiction?.Count ?? 0;
        if (jurisdictionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.jurisdiction' cardinality must be 0..*", new[] { nameof(Jurisdiction) });
        }
        // Validate DerivedFromCanonical cardinality
        var derivedfromcanonicalCount = DerivedFromCanonical?.Count ?? 0;
        if (derivedfromcanonicalCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.derivedFromCanonical' cardinality must be 0..*", new[] { nameof(DerivedFromCanonical) });
        }
        // Validate DerivedFromUri cardinality
        var derivedfromuriCount = DerivedFromUri?.Count ?? 0;
        if (derivedfromuriCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.derivedFromUri' cardinality must be 0..*", new[] { nameof(DerivedFromUri) });
        }
        // Validate Subject cardinality
        var subjectCount = Subject?.Count ?? 0;
        if (subjectCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.subject' cardinality must be 0..*", new[] { nameof(Subject) });
        }
        // Validate Category cardinality
        var categoryCount = Category?.Count ?? 0;
        if (categoryCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.category' cardinality must be 0..*", new[] { nameof(Category) });
        }
        if (Code == null)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.code' cardinality must be 1..1", new[] { nameof(Code) });
        }
        // Validate PermittedDataType cardinality
        var permitteddatatypeCount = PermittedDataType?.Count ?? 0;
        if (permitteddatatypeCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.permittedDataType' cardinality must be 0..*", new[] { nameof(PermittedDataType) });
        }
        // Validate Specimen cardinality
        var specimenCount = Specimen?.Count ?? 0;
        if (specimenCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.specimen' cardinality must be 0..*", new[] { nameof(Specimen) });
        }
        // Validate Device cardinality
        var deviceCount = Device?.Count ?? 0;
        if (deviceCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.device' cardinality must be 0..*", new[] { nameof(Device) });
        }
        // Validate PermittedUnit cardinality
        var permittedunitCount = PermittedUnit?.Count ?? 0;
        if (permittedunitCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.permittedUnit' cardinality must be 0..*", new[] { nameof(PermittedUnit) });
        }
        // Validate QualifiedValue cardinality
        var qualifiedvalueCount = QualifiedValue?.Count ?? 0;
        if (qualifiedvalueCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.qualifiedValue' cardinality must be 0..*", new[] { nameof(QualifiedValue) });
        }
        // Validate Extension cardinality
        var extensionCount = Extension?.Count ?? 0;
        if (extensionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.qualifiedValue.extension' cardinality must be 0..*", new[] { nameof(Extension) });
        }
        // Validate ModifierExtension cardinality
        var modifierextensionCount = ModifierExtension?.Count ?? 0;
        if (modifierextensionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.qualifiedValue.modifierExtension' cardinality must be 0..*", new[] { nameof(ModifierExtension) });
        }
        // Validate AppliesTo cardinality
        var appliestoCount = AppliesTo?.Count ?? 0;
        if (appliestoCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.qualifiedValue.appliesTo' cardinality must be 0..*", new[] { nameof(AppliesTo) });
        }
        // Validate HasMember cardinality
        var hasmemberCount = HasMember?.Count ?? 0;
        if (hasmemberCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.hasMember' cardinality must be 0..*", new[] { nameof(HasMember) });
        }
        // Validate Component cardinality
        var componentCount = Component?.Count ?? 0;
        if (componentCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.component' cardinality must be 0..*", new[] { nameof(Component) });
        }
        // Validate Extension cardinality
        var extensionCount = Extension?.Count ?? 0;
        if (extensionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.component.extension' cardinality must be 0..*", new[] { nameof(Extension) });
        }
        // Validate ModifierExtension cardinality
        var modifierextensionCount = ModifierExtension?.Count ?? 0;
        if (modifierextensionCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.component.modifierExtension' cardinality must be 0..*", new[] { nameof(ModifierExtension) });
        }
        if (Code == null)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.component.code' cardinality must be 1..1", new[] { nameof(Code) });
        }
        // Validate PermittedDataType cardinality
        var permitteddatatypeCount = PermittedDataType?.Count ?? 0;
        if (permitteddatatypeCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.component.permittedDataType' cardinality must be 0..*", new[] { nameof(PermittedDataType) });
        }
        // Validate PermittedUnit cardinality
        var permittedunitCount = PermittedUnit?.Count ?? 0;
        if (permittedunitCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.component.permittedUnit' cardinality must be 0..*", new[] { nameof(PermittedUnit) });
        }
        // Validate QualifiedValue cardinality
        var qualifiedvalueCount = QualifiedValue?.Count ?? 0;
        if (qualifiedvalueCount < 0)
        {
            yield return new ValidationResult("Element 'ObservationDefinition.component.qualifiedValue' cardinality must be 0..*", new[] { nameof(QualifiedValue) });
        }

        // ValueSet binding validation
        // Validate Language ValueSet binding
        if (Language != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/all-languages|5.0.0
            // This requires a terminology service or local ValueSet cache
        }
        // Validate VersionAlgorithm ValueSet binding
        if (VersionAlgorithm != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/version-algorithm
            // This requires a terminology service or local ValueSet cache
        }
        // Validate Status ValueSet binding
        if (Status != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/publication-status|5.0.0
            // This requires a terminology service or local ValueSet cache
        }
        // Validate Jurisdiction ValueSet binding
        if (Jurisdiction != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/jurisdiction
            // This requires a terminology service or local ValueSet cache
        }
        // Validate PermittedDataType ValueSet binding
        if (PermittedDataType != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/permitted-data-type|5.0.0
            // This requires a terminology service or local ValueSet cache
        }
        // Validate Context ValueSet binding
        if (Context != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/referencerange-meaning
            // This requires a terminology service or local ValueSet cache
        }
        // Validate Gender ValueSet binding
        if (Gender != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/administrative-gender|5.0.0
            // This requires a terminology service or local ValueSet cache
        }
        // Validate RangeCategory ValueSet binding
        if (RangeCategory != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/observation-range-category|5.0.0
            // This requires a terminology service or local ValueSet cache
        }
        // Validate PermittedDataType ValueSet binding
        if (PermittedDataType != null)
        {
            // TODO: Implement ValueSet validation for http://hl7.org/fhir/ValueSet/permitted-data-type|5.0.0
            // This requires a terminology service or local ValueSet cache
        }

        // Constraint validation
        // Constraint: cnl-0
        // Expression: name.exists() implies name.matches('^[A-Z]([A-Za-z0-9_]){1,254}$')
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("name.exists() implies name.matches('^[A-Z]([A-Za-z0-9_]){1,254}$')"))
        // {
        //     yield return new ValidationResult("Name should be usable as an identifier for the module by machine processing applications such as code generation", new[] { nameof(ObservationDefinition) });
        // }
        // Constraint: obd-0
        // Expression: permittedUnit.exists() implies (permittedDataType = 'Quantity').exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("permittedUnit.exists() implies (permittedDataType = 'Quantity').exists()"))
        // {
        //     yield return new ValidationResult("If permittedUnit exists, then permittedDataType=Quantity must exist.", new[] { nameof(ObservationDefinition) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Meta) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(ImplicitRules) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Language) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Text) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Extension) });
        // }
        // Constraint: ext-1
        // Expression: extension.exists() != value.exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("extension.exists() != value.exists()"))
        // {
        //     yield return new ValidationResult("Must have either extensions or value[x], not both", new[] { nameof(Extension) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(ModifierExtension) });
        // }
        // Constraint: ext-1
        // Expression: extension.exists() != value.exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("extension.exists() != value.exists()"))
        // {
        //     yield return new ValidationResult("Must have either extensions or value[x], not both", new[] { nameof(ModifierExtension) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Url) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Identifier) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Version) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(VersionAlgorithm) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Name) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Title) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Status) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Experimental) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Date) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Publisher) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Contact) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Description) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(UseContext) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Jurisdiction) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Purpose) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Copyright) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(CopyrightLabel) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(ApprovalDate) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(LastReviewDate) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(EffectivePeriod) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(DerivedFromCanonical) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(DerivedFromUri) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Subject) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(PerformerType) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Category) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Code) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(PermittedDataType) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(MultipleResultsAllowed) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(BodySite) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Method) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Specimen) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Device) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(PreferredReportName) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(PermittedUnit) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(QualifiedValue) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Extension) });
        // }
        // Constraint: ext-1
        // Expression: extension.exists() != value.exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("extension.exists() != value.exists()"))
        // {
        //     yield return new ValidationResult("Must have either extensions or value[x], not both", new[] { nameof(Extension) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(ModifierExtension) });
        // }
        // Constraint: ext-1
        // Expression: extension.exists() != value.exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("extension.exists() != value.exists()"))
        // {
        //     yield return new ValidationResult("Must have either extensions or value[x], not both", new[] { nameof(ModifierExtension) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Context) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(AppliesTo) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Gender) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Age) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(GestationalAge) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Condition) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(RangeCategory) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Range) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(ValidCodedValueSet) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(NormalCodedValueSet) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(AbnormalCodedValueSet) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(CriticalCodedValueSet) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(HasMember) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Component) });
        // }
        // Constraint: obd-1
        // Expression: permittedUnit.exists() implies (permittedDataType = 'Quantity').exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("permittedUnit.exists() implies (permittedDataType = 'Quantity').exists()"))
        // {
        //     yield return new ValidationResult("If permittedUnit exists, then permittedDataType=Quantity must exist.", new[] { nameof(Component) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Extension) });
        // }
        // Constraint: ext-1
        // Expression: extension.exists() != value.exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("extension.exists() != value.exists()"))
        // {
        //     yield return new ValidationResult("Must have either extensions or value[x], not both", new[] { nameof(Extension) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(ModifierExtension) });
        // }
        // Constraint: ext-1
        // Expression: extension.exists() != value.exists()
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("extension.exists() != value.exists()"))
        // {
        //     yield return new ValidationResult("Must have either extensions or value[x], not both", new[] { nameof(ModifierExtension) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(Code) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(PermittedDataType) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(PermittedUnit) });
        // }
        // Constraint: ele-1
        // Expression: hasValue() or (children().count() > id.count())
        // TODO: Implement FHIRPath expression evaluation
        // if (!EvaluateFHIRPath("hasValue() or (children().count() > id.count())"))
        // {
        //     yield return new ValidationResult("All FHIR elements must have a @value or children", new[] { nameof(QualifiedValue) });
        // }
    }

}
