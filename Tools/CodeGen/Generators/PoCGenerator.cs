using System.Text;
using CodeGen.Generators;
using CodeGen.Models;
using CodeGen.Services;

namespace CodeGen.Generators;

public sealed class PoCGenerator : IGenerator
{
    private readonly IPropertyEmitter _emitter;
    private readonly IReadOnlyDictionary<string, IReadOnlyDictionary<string, string>> _docs;
    private readonly IReadOnlyDictionary<string, IReadOnlyDictionary<string, IReadOnlyList<string>>>? _choices;
    private readonly IReadOnlyDictionary<string, IReadOnlyDictionary<string, IReadOnlyList<string>>>? _types;

    public PoCGenerator(
        IPropertyEmitter emitter,
        IReadOnlyDictionary<string, IReadOnlyDictionary<string, string>> docs,
        IReadOnlyDictionary<string, IReadOnlyDictionary<string, IReadOnlyList<string>>>? choices,
        IReadOnlyDictionary<string, IReadOnlyDictionary<string, IReadOnlyList<string>>>? types)
    {
        _emitter = emitter;
        _docs = docs;
        _choices = choices;
        _types = types;
    }

    public PoCGenerator(IPropertyEmitter emitter, IReadOnlyDictionary<string, IReadOnlyDictionary<string, string>> docs)
    {
        _emitter = emitter;
        _docs = docs;
    }

    // Documentation helpers
    private string? GetDoc(string resourceType, string key)
    {
        if (_docs != null && _docs.TryGetValue(resourceType, out var dict) && dict.TryGetValue(key, out var txt))
            return txt;
        return null;
    }
    private static string XmlEscape(string? s)
    {
        if (string.IsNullOrEmpty(s)) return string.Empty;
        return s.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }
    private static void AppendDocSummary(StringBuilder sb, string indent, string? text)
    {
        if (string.IsNullOrWhiteSpace(text)) return;
        var t = XmlEscape(text);
        sb.AppendLine($"{indent}/// <summary>");
        sb.AppendLine($"{indent}/// {t}");
        sb.AppendLine($"{indent}/// </summary>");
    }

    public string BuildResourceRegistry(string ns, string version, IEnumerable<string> resourceTypes)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine($"    internal static class ResourceRegistry_{version}");
        sb.AppendLine("    {");
        sb.AppendLine("        public static IReadOnlyCollection<string> ResourceTypes { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase)");
        sb.AppendLine("        {");
        foreach (var r in resourceTypes)
            sb.AppendLine($"            \"{r}\",");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    // Helper to map choice member names from StructureDefinition
    private IReadOnlyList<string> GetChoicePropNames(string resourceType, string baseElementPathWithX)
    {
        if (_choices != null && _choices.TryGetValue(resourceType, out var dict) && dict.TryGetValue(baseElementPathWithX, out var codes))
        {
            var list = new List<string>();
            foreach (var code in codes)
            {
                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                list.Add(ChoiceNameMapper.ToChoicePropertyName(baseElementPathWithX, suffix));
            }
            return list;
        }
        return Array.Empty<string>();
    }

    public string BuildResourceGeneric(string ns, string resourceType, IReadOnlyDictionary<string, Cardinality> cards)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using DataTypeServices.DataTypes.PrimitiveTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.ComplexTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.SpecialTypes;");
        sb.AppendLine("using System.Text.Json.Nodes;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using FhirCore.Base;");
        sb.AppendLine("using DataTypeServices.TypeFramework;");
        sb.AppendLine("using DataTypeServices.DataTypes.MetaTypes;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        AppendDocSummary(sb, "    ", GetDoc(resourceType, resourceType));
        sb.AppendLine($"    public partial class {resourceType} : ResourceBase");
        sb.AppendLine("    {");
        sb.AppendLine($"        public override string ResourceType => \"{resourceType}\";");
        sb.AppendLine();
        sb.AppendLine($"        public {resourceType}() {{ }}");
        sb.AppendLine($"        public {resourceType}(string json) {{ SetRawFrom(JsonNode.Parse(json)); }}");
        sb.AppendLine($"        public {resourceType}(JsonNode? source) {{ SetRawFrom(source); }}");
        sb.AppendLine("        protected override void OnPropertyChanged(string propertyName, object? newValue) { base.OnPropertyChanged(propertyName, newValue); }");
        sb.AppendLine();

        // Properties that ResourceBase already defines and should not be re-generated on resources
        var skipResourceBaseProps = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        { "id", "extension", "modifierExtension", "implicitRules", "language", "meta" };

        // Properties that Element/BackboneElement already define and should not be re-generated on backbone classes
        var skipElementProps = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        { "id", "extension", "modifierExtension" };

        // Build index of paths for this resource
        var allPaths = cards.Keys.Where(k => k.StartsWith(resourceType + ".", StringComparison.Ordinal)).ToList();
        var topSegs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var hasChild = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var p in allPaths)
        {
            var rel = p.Substring(resourceType.Length + 1); // e.g., "name" or "component.code"
            if (string.IsNullOrWhiteSpace(rel)) continue;
            var dot = rel.IndexOf('.');
            if (dot < 0)
            {
                topSegs.Add(rel);
            }
            else
            {
                var first = rel.Substring(0, dot);
                topSegs.Add(first);
                hasChild.Add(first);
            }
        }

        // Generate resource-level properties
        foreach (var seg in topSegs.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
        {
            var fullPath = resourceType + "." + seg;
            var propName = char.ToUpperInvariant(seg[0]) + seg.Substring(1);

            // Skip properties already provided by ResourceBase
            if (skipResourceBaseProps.Contains(seg))
                continue;

            // Backbone at top-level
            if (hasChild.Contains(seg))
            {
                var nestedClassName = resourceType + "_" + propName;
                sb.AppendLine("        " + _emitter.EmitClr(fullPath, nestedClassName, propName, cards));
                sb.AppendLine();

                // Emit nested class
                Console.WriteLine($"[CodeGen]   [+] Backbone {nestedClassName} (from {fullPath})");
                AppendDocSummary(sb, "        ", GetDoc(resourceType, fullPath));
                sb.AppendLine($"        public partial class {nestedClassName} : BackboneElement<{nestedClassName}>");
                sb.AppendLine("        {");
                // Emit required type name override for backbone classes
                var nestedLower = char.ToLowerInvariant(nestedClassName[0]) + nestedClassName.Substring(1);
                sb.AppendLine($"            public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"{nestedClassName}\" : \"{nestedLower}\";");

                // Find immediate children: paths with exactly two segments rel == "seg.child"
                var childPaths = allPaths.Where(p =>
                {
                    var rel = p.Substring(resourceType.Length + 1);
                    if (!rel.StartsWith(seg + ".", StringComparison.Ordinal)) return false;
                    return rel.Count(c => c == '.') == 1; // exactly one dot beyond top
                }).OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();

                foreach (var cp in childPaths)
                {
                    var rel = cp.Substring(resourceType.Length + 1); // seg.child
                    var childName = rel.Substring(seg.Length + 1);    // child or child[x]
                    var childPropName = char.ToUpperInvariant(childName[0]) + childName.Substring(1);

                    // Choice in backbone
                    if (childName.Contains("[x]"))
                    {
                        if (_types != null && _types.TryGetValue(resourceType, out var tmap) && tmap.TryGetValue(cp, out var codes))
                        {
                            var allPropNames = new List<string>();
                            foreach (var code in codes)
                            {
                                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                                allPropNames.Add(ChoiceNameMapper.ToChoicePropertyName(cp, suffix));
                            }
                            foreach (var code in codes)
                            {
                                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                                var choicePropName = ChoiceNameMapper.ToChoicePropertyName(cp, suffix);
                                var csType = TypeMapService.Map(code);
                                sb.AppendLine("            " + _emitter.EmitChoiceWithMutexBackbone(cp, csType, choicePropName, cards, allPropNames));
                                sb.AppendLine();
                            }
                        }
                        continue;
                    }

                    // Detect if this child itself has sub-children (i.e., is a nested backbone)
                    bool hasGrandChildren = allPaths.Any(p =>
                    {
                        var r = p.Substring(resourceType.Length + 1);
                        return r.StartsWith(seg + "." + childName + ".", StringComparison.Ordinal);
                    });

                    if (hasGrandChildren)
                    {
                        // Emit property typed to nested-nested backbone class
                        var grandClassName = nestedClassName + "_" + childPropName;
                        sb.AppendLine("            " + _emitter.EmitClrBackbone(cp, grandClassName, childPropName, cards));
                        sb.AppendLine();

                        // Emit the nested-nested class
                        Console.WriteLine($"[CodeGen]   [+] Backbone {grandClassName} (from {cp})");
                        AppendDocSummary(sb, "            ", GetDoc(resourceType, cp));
                        sb.AppendLine($"            public partial class {grandClassName} : BackboneElement<{grandClassName}>");
                        sb.AppendLine("            {");
                        var grandLower = char.ToLowerInvariant(grandClassName[0]) + grandClassName.Substring(1);
                        sb.AppendLine($"                public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"{grandClassName}\" : \"{grandLower}\";");

                        // Immediate grandchildren: rel == "seg.child.grand"
                        var grandPaths = allPaths.Where(p =>
                        {
                            var r = p.Substring(resourceType.Length + 1);
                            if (!r.StartsWith(seg + "." + childName + ".", StringComparison.Ordinal)) return false;
                            return r.Count(c => c == '.') == 2; // exactly one more level
                        }).OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();

                        foreach (var gp in grandPaths)
                        {
                            var r = gp.Substring(resourceType.Length + 1); // seg.child.grand
                            var grandName = r.Substring((seg + "." + childName + ".").Length); // grand or grand[x]

                            if (grandName.Contains("[x]"))
                            {
                                if (_types != null && _types.TryGetValue(resourceType, out var tmap2) && tmap2.TryGetValue(gp, out var codes2))
                                {
                                    var allNames = new List<string>();
                                    foreach (var code in codes2)
                                    {
                                        var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                                        allNames.Add(ChoiceNameMapper.ToChoicePropertyName(gp, suffix));
                                    }
                                    foreach (var code in codes2)
                                    {
                                        var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                                        var choiceProp = ChoiceNameMapper.ToChoicePropertyName(gp, suffix);
                                        var csType = TypeMapService.Map(code);
                                        sb.AppendLine("                " + _emitter.EmitChoiceWithMutexBackbone(gp, csType, choiceProp, cards, allNames));
                                        sb.AppendLine();
                                    }
                                }
                                continue;
                            }

                            if (_types != null && _types.TryGetValue(resourceType, out var typesMap2) && typesMap2.TryGetValue(gp, out var grandCodes))
                            {
                                var grandPropName = char.ToUpperInvariant(grandName[0]) + grandName.Substring(1);

                                // Skip Element/Backbone common fields at all depths
                                if (skipElementProps.Contains(grandName))
                                    continue;

                                // Immediate deeper children: seg.child.grand.deep
                                var deepPaths = allPaths.Where(p =>
                                {
                                    var rr = p.Substring(resourceType.Length + 1);
                                    if (!rr.StartsWith(seg + "." + childName + "." + grandName + ".", StringComparison.Ordinal)) return false;
                                    return rr.Count(c => c == '.') == 3;
                                }).OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();

                                if (deepPaths.Count > 0)
                                {
                                    var deepClassName = grandClassName + "_" + grandPropName;
                                    // property typed to the deeper class
                                    sb.AppendLine("                " + _emitter.EmitClrBackbone(gp, deepClassName, grandPropName, cards));
                                    sb.AppendLine();

                                    // Emit the deeper nested class
                                    Console.WriteLine($"[CodeGen]   [+] Backbone {deepClassName} (from {gp})");
                                    AppendDocSummary(sb, "                ", GetDoc(resourceType, gp));
                                    sb.AppendLine($"                public partial class {deepClassName} : BackboneElement<{deepClassName}>");
                                    sb.AppendLine("                {");
                                    var deepLower = char.ToLowerInvariant(deepClassName[0]) + deepClassName.Substring(1);
                                    sb.AppendLine($"                    public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"{deepClassName}\" : \"{deepLower}\";");

                                    foreach (var dp in deepPaths)
                                    {
                                        var rr = dp.Substring(resourceType.Length + 1); // seg.child.grand.deep
                                        var deepName = rr.Substring((seg + "." + childName + "." + grandName + ".").Length);

                                        // Skip Element/Backbone common fields at all depths
                                        if (skipElementProps.Contains(deepName))
                                            continue;

                                        if (deepName.Contains("[x]"))
                                        {
                                            if (_types.TryGetValue(resourceType, out var tmap3) && tmap3.TryGetValue(dp, out var codes3))
                                            {
                                                var allNames3 = new List<string>();
                                                foreach (var code in codes3)
                                                {
                                                    var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                                                    var choiceProp3 = ChoiceNameMapper.ToChoicePropertyName(dp, suffix);
                                                    var csType3 = TypeMapService.Map(code);
                                                    allNames3.Add(choiceProp3);
                                                    sb.AppendLine("                    " + _emitter.EmitChoiceWithMutexBackbone(dp, csType3, choiceProp3, cards, allNames3));
                                                    sb.AppendLine();
                                                }
                                            }
                                            continue;
                                        }

                                        if (_types.TryGetValue(resourceType, out var typesMap3) && typesMap3.TryGetValue(dp, out var deepCodes))
                                        {
                                            var deepPropName = char.ToUpperInvariant(deepName[0]) + deepName.Substring(1);

                                            // Check if this deep node has its own children (very deep level)
                                            var veryDeepPaths = allPaths.Where(p =>
                                            {
                                                var r3 = p.Substring(resourceType.Length + 1);
                                                if (!r3.StartsWith(seg + "." + childName + "." + grandName + "." + deepName + ".", StringComparison.Ordinal)) return false;
                                                return r3.Count(c => c == '.') == 4;
                                            }).OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();

                                            if (veryDeepPaths.Count > 0 || (deepCodes.Count > 0 && string.Equals(deepCodes[0], "BackboneElement", StringComparison.Ordinal)))
                                            {
                                                var veryDeepClassName = deepClassName + "_" + deepPropName;
                                                sb.AppendLine("                    " + _emitter.EmitClrBackbone(dp, veryDeepClassName, deepPropName, cards));
                                                sb.AppendLine();

                                                Console.WriteLine($"[CodeGen]   [+] Backbone {veryDeepClassName} (from {dp})");
                                                AppendDocSummary(sb, "                    ", GetDoc(resourceType, dp));
                                                sb.AppendLine($"                    public partial class {veryDeepClassName} : BackboneElement<{veryDeepClassName}>");
                                                sb.AppendLine("                    {");
                                                var veryDeepLower = char.ToLowerInvariant(veryDeepClassName[0]) + veryDeepClassName.Substring(1);
                                                sb.AppendLine($"                        public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"{veryDeepClassName}\" : \"{veryDeepLower}\";");

                                                foreach (var vp in veryDeepPaths)
                                                {
                                                    var r4 = vp.Substring(resourceType.Length + 1); // seg.child.grand.deep.very
                                                    var veryName = r4.Substring((seg + "." + childName + "." + grandName + "." + deepName + ".").Length);

                                                    // Skip Element/Backbone common fields at all depths
                                                    if (skipElementProps.Contains(veryName))
                                                        continue;

                                                    if (veryName.Contains("[x]"))
                                                    {
                                                        if (_types.TryGetValue(resourceType, out var tmap4) && tmap4.TryGetValue(vp, out var codes4))
                                                        {
                                                            var allNames4 = new List<string>();
                                                            foreach (var code in codes4)
                                                            {
                                                                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                                                                allNames4.Add(ChoiceNameMapper.ToChoicePropertyName(vp, suffix));
                                                            }
                                                            foreach (var code in codes4)
                                                            {
                                                                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                                                                var choiceProp4 = ChoiceNameMapper.ToChoicePropertyName(vp, suffix);
                                                                var csType4 = TypeMapService.Map(code);
                                                                sb.AppendLine("                        " + _emitter.EmitChoiceWithMutexBackbone(vp, csType4, choiceProp4, cards, allNames4));
                                                                sb.AppendLine();
                                                            }
                                                        }
                                                        continue;
                                                    }

                                                    if (_types.TryGetValue(resourceType, out var typesMap4) && typesMap4.TryGetValue(vp, out var veryCodes))
                                                    {
                                                        var csType4 = veryCodes.Count > 0 ? TypeMapService.Map(veryCodes[0]) : "FhirString";
                                                        var veryPropName = char.ToUpperInvariant(veryName[0]) + veryName.Substring(1);
                                                        sb.AppendLine("                        " + _emitter.EmitClrBackbone(vp, csType4, veryPropName, cards));
                                                        sb.AppendLine();
                                                    }
                                                }

                                                sb.AppendLine("                    }");
                                                sb.AppendLine();
                                            }
                                            else
                                            {
                                                // Skip Element/Backbone common fields at all depths
                                                if (skipElementProps.Contains(deepName))
                                                    continue;

                                                var csType3 = deepCodes.Count > 0 ? TypeMapService.Map(deepCodes[0]) : "FhirString";
                                                sb.AppendLine("                    " + _emitter.EmitClrBackbone(dp, csType3, deepPropName, cards));
                                                sb.AppendLine();
                                            }
                                        }
                                    }

                                    sb.AppendLine("                }");
                                    sb.AppendLine();
                                }
                                else
                                {
                                    var csType2 = grandCodes.Count > 0 ? TypeMapService.Map(grandCodes[0]) : "FhirString";
                                    sb.AppendLine("                " + _emitter.EmitClrBackbone(gp, csType2, grandPropName, cards));
                                    sb.AppendLine();
                                }
                            }
                        }

                        sb.AppendLine("            }");
                        sb.AppendLine();
                    }
                    else
                    {
                        // Normal property in backbone
                        if (_types != null && _types.TryGetValue(resourceType, out var typesMap) && typesMap.TryGetValue(cp, out var childCodes))
                        {
                            // Skip fields already provided by Element/BackboneElement
                            if (skipElementProps.Contains(childName))
                                continue;

                            var csType = childCodes.Count > 0 ? TypeMapService.Map(childCodes[0]) : "FhirString";
                            sb.AppendLine("            " + _emitter.EmitClrBackbone(cp, csType, childPropName, cards));
                            sb.AppendLine();
                        }
                    }
                }

                sb.AppendLine("        }");
                sb.AppendLine();
            }
            else
            {
                // Normal top-level property
                if (_types != null && _types.TryGetValue(resourceType, out var typesMap) && typesMap.TryGetValue(fullPath, out var codes))
                {
                    if (seg.Contains("[x]"))
                    {
                        var propNames = new List<string>();
                        foreach (var code in codes)
                        {
                            var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                            propNames.Add(ChoiceNameMapper.ToChoicePropertyName(fullPath, suffix));
                        }
                        foreach (var code in codes)
                        {
                            var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                            var choicePropName = ChoiceNameMapper.ToChoicePropertyName(fullPath, suffix);
                            var csType = TypeMapService.Map(code);
                            sb.AppendLine("        " + _emitter.EmitChoiceWithMutex(fullPath, csType, choicePropName, cards, propNames));
                            sb.AppendLine();
                        }
                    }
                    else
                    {
                        var csType = codes.Count > 0 ? TypeMapService.Map(codes[0]) : "FhirString";
                        sb.AppendLine("        " + _emitter.EmitClr(fullPath, csType, propName, cards));
                        sb.AppendLine();
                    }
                }
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public string BuildFluentExtensions(string ns, string resourceType, IReadOnlyDictionary<string, Cardinality> cards)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using DataTypeServices.DataTypes.PrimitiveTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.ComplexTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.SpecialTypes;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine($"    public static class {resourceType}FluentExtensions");
        sb.AppendLine("    {");

        var allPaths = cards.Keys.Where(k => k.StartsWith(resourceType + ".", StringComparison.Ordinal)).ToList();
        var topSegs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var hasChild = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var p in allPaths)
        {
            var rel = p.Substring(resourceType.Length + 1);
            if (string.IsNullOrWhiteSpace(rel)) continue;
            var dot = rel.IndexOf('.');
            if (dot < 0)
                topSegs.Add(rel);
            else
            {
                var first = rel.Substring(0, dot);
                topSegs.Add(first);
                hasChild.Add(first);
            }
        }

        var skipResourceBaseProps = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        { "id", "extension", "modifierExtension", "implicitRules", "language", "meta" };

        foreach (var seg in topSegs.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
        {
            if (skipResourceBaseProps.Contains(seg)) continue;
            var fullPath = resourceType + "." + seg;
            var propName = char.ToUpperInvariant(seg[0]) + seg.Substring(1);

            if (_types != null && _types.TryGetValue(resourceType, out var typesMap) && typesMap.TryGetValue(fullPath, out var codes))
            {
                if (seg.Contains("[x]"))
                {
                    foreach (var code in codes)
                    {
                        var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                        var choicePropName = ChoiceNameMapper.ToChoicePropertyName(fullPath, suffix);
                        var csType = TypeMapService.Map(code);
                        sb.AppendLine($"        public static {resourceType} With{choicePropName}(this {resourceType} r, {csType} value) {{ r.{choicePropName} = value; return r; }}");
                    }
                    continue;
                }
                else
                {
                    var csType = codes.Count > 0 ? TypeMapService.Map(codes[0]) : "FhirString";
                    cards.TryGetValue(fullPath, out var c);
                    c ??= Cardinality.Optional;
                    if (c.IsList)
                    {
                        sb.AppendLine($"        public static {resourceType} Add{propName}(this {resourceType} r, {csType} item) {{ r.{propName} ??= new List<{csType}>(); r.{propName}!.Add(item); return r; }}");
                    }
                    else
                    {
                        sb.AppendLine($"        public static {resourceType} With{propName}(this {resourceType} r, {csType} value) {{ r.{propName} = value; return r; }}");
                    }
                }
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public string BuildPatient(string ns, IReadOnlyDictionary<string, Cardinality> cards)
    {
        var e = _emitter;
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using DataTypeServices.DataTypes.PrimitiveTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.ComplexTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.SpecialTypes;");
        sb.AppendLine("using System.Text.Json.Nodes;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using FhirCore.Base;");
        sb.AppendLine("using DataTypeServices.TypeFramework;");
        sb.AppendLine("using DataTypeServices.DataTypes.MetaTypes;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        var patientSummary = GetDoc("Patient", "Patient");
        AppendDocSummary(sb, "    ", patientSummary);
        sb.AppendLine("    public partial class Patient : ResourceBase");
        sb.AppendLine("    {");
        sb.AppendLine("        public override string ResourceType => \"Patient\";");
        sb.AppendLine();
        AppendDocSummary(sb, "        ", "Initializes a new instance of Patient.");
        sb.AppendLine("        public Patient() { }");
        AppendDocSummary(sb, "        ", "Initializes a new instance of Patient from JSON string.");
        sb.AppendLine("        public Patient(string json) { SetRawFrom(JsonNode.Parse(json)); }");
        AppendDocSummary(sb, "        ", "Initializes a new instance of Patient from JsonNode.");
        sb.AppendLine("        public Patient(JsonNode? source) { SetRawFrom(source); }");
        AppendDocSummary(sb, "        ", "Raw JSON backing for dot-notation access.");
        sb.AppendLine("        // JSON handled by ResourceBase.UpdateRaw via OnPropertyChanged");
        sb.AppendLine("        protected override void OnPropertyChanged(string propertyName, object? newValue) { base.OnPropertyChanged(propertyName, newValue); }");
        sb.AppendLine();

        sb.AppendLine();

        sb.AppendLine("        // Identifiers and basic demographics");
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.identifier"));
        sb.AppendLine("        " + e.EmitClr("Patient.identifier", "Identifier", "Identifier", cards));
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.active"));
        sb.AppendLine("        " + e.EmitClr("Patient.active", "FhirBoolean", "Active", cards));
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.name"));
        sb.AppendLine("        " + e.EmitClr("Patient.name", "HumanName", "Name", cards));
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.telecom"));
        sb.AppendLine("        " + e.EmitClr("Patient.telecom", "ContactPoint", "Telecom", cards));
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.gender"));
        // Standard emit now produces JsonPropertyName + OnPropertyChangedByClr
        sb.AppendLine("        " + e.EmitClr("Patient.gender", "FhirCode", "Gender", cards));
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.birthDate"));
        sb.AppendLine("        " + e.EmitClr("Patient.birthDate", "FhirDate", "BirthDate", cards));
        sb.AppendLine();
        sb.AppendLine("        // Deceased[x] (choice) with mutex");
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.deceased[x]"));
        var decPropNames = GetChoicePropNames("Patient", "Patient.deceased[x]");
        if (_choices != null && _choices.TryGetValue("Patient", out var patChoices1) && patChoices1.TryGetValue("Patient.deceased[x]", out var decCodes) && decPropNames.Count > 0)
        {
            foreach (var code in decCodes)
            {
                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                var propName = ChoiceNameMapper.ToChoicePropertyName("Patient.deceased[x]", suffix);
                var csType = TypeMapService.Map(code);
                sb.AppendLine("        " + e.EmitChoiceWithMutex("Patient.deceased[x]", csType, propName, cards, decPropNames));
            }
        }
        sb.AppendLine();
        sb.AppendLine("        // Address and marital status");
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.address"));
        sb.AppendLine("        " + e.EmitClr("Patient.address", "Address", "Address", cards));
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.maritalStatus"));
        sb.AppendLine("        " + e.EmitClr("Patient.maritalStatus", "CodeableConcept", "MaritalStatus", cards));
        sb.AppendLine();
        sb.AppendLine("        // MultipleBirth[x] (choice) with mutex");
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.multipleBirth[x]"));
        var mbPropNames = GetChoicePropNames("Patient", "Patient.multipleBirth[x]");
        if (_choices != null && _choices.TryGetValue("Patient", out var patChoices2) && patChoices2.TryGetValue("Patient.multipleBirth[x]", out var mbCodes) && mbPropNames.Count > 0)
        {
            foreach (var code in mbCodes)
            {
                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                var propName = ChoiceNameMapper.ToChoicePropertyName("Patient.multipleBirth[x]", suffix);
                var csType = TypeMapService.Map(code);
                sb.AppendLine("        " + e.EmitChoiceWithMutex("Patient.multipleBirth[x]", csType, propName, cards, mbPropNames));
            }
        }
        sb.AppendLine();
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.photo"));
        sb.AppendLine("        " + e.EmitClr("Patient.photo", "Attachment", "Photo", cards));
        sb.AppendLine();
        sb.AppendLine("        // Backbone: Patient.Contact");
        sb.AppendLine("        " + e.EmitClr("Patient.contact", "Patient_Contact", "Contact", cards));
        sb.AppendLine();
        sb.AppendLine("        // Backbone: Patient.Communication");
        sb.AppendLine("        " + e.EmitClr("Patient.communication", "Patient_Communication", "Communication", cards));
        sb.AppendLine();
        sb.AppendLine("        // Care providers and managing organization (References)");
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.generalPractitioner"));
        sb.AppendLine("        " + e.EmitClr("Patient.generalPractitioner", "ReferenceType", "GeneralPractitioner", cards));
        AppendDocSummary(sb, "        ", GetDoc("Patient", "Patient.managingOrganization"));
        sb.AppendLine("        " + e.EmitClr("Patient.managingOrganization", "ReferenceType", "ManagingOrganization", cards));
        sb.AppendLine();
        sb.AppendLine("        // Backbone: Patient.Link");
        sb.AppendLine("        " + e.EmitClr("Patient.link", "Patient_Link", "Link", cards));
        sb.AppendLine();
        sb.AppendLine("        // Nested backbone elements");
        sb.AppendLine("        public partial class Patient_Contact : BackboneElement<Patient_Contact>");
        sb.AppendLine("        {");
        sb.AppendLine("            public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"Contact\" : \"contact\";");
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.contact.relationship", "CodeableConcept", "Relationship", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.contact.name", "HumanName", "Name", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.contact.telecom", "ContactPoint", "Telecom", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.contact.address", "Address", "Address", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.contact.gender", "FhirCode", "Gender", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.contact.organization", "ReferenceType", "Organization", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.contact.period", "Period", "Period", cards));
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public partial class Patient_Communication : BackboneElement<Patient_Communication>");
        sb.AppendLine("        {");
        sb.AppendLine("            public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"Communication\" : \"communication\";");
        sb.AppendLine("            public required CodeableConcept Language { get; set; }");
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.communication.preferred", "FhirBoolean", "Preferred", cards));
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public partial class Patient_Link : BackboneElement<Patient_Link>");
        sb.AppendLine("        {");
        sb.AppendLine("            public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"Link\" : \"link\";");
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.link.other", "ReferenceType", "Other", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Patient.link.type", "FhirCode", "Type", cards));
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public string BuildObservation(string ns, IReadOnlyDictionary<string, Cardinality> cards)
    {
        var e = _emitter;
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using DataTypeServices.DataTypes.PrimitiveTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.ComplexTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.SpecialTypes;");
        sb.AppendLine("using System.Text.Json.Nodes;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using FhirCore.Base;");
        sb.AppendLine("using DataTypeServices.TypeFramework;");
        sb.AppendLine("using DataTypeServices.DataTypes.MetaTypes;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine("    public partial class Observation : ResourceBase");
        sb.AppendLine("    {");
        sb.AppendLine("        public override string ResourceType => \"Observation\";");
        sb.AppendLine();
        sb.AppendLine("        public Observation() { }");
        sb.AppendLine("        public Observation(string json) { SetRawFrom(JsonNode.Parse(json)); }");
        sb.AppendLine("        public Observation(JsonNode? source) { SetRawFrom(source); }");
        sb.AppendLine("        // JSON handled by ResourceBase.UpdateRaw via OnPropertyChanged");
        sb.AppendLine();
        sb.AppendLine("        " + e.EmitClr("Observation.status", "FhirCode", "Status", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.category", "CodeableConcept", "Category", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.code", "CodeableConcept", "Code", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.subject", "ReferenceType", "Subject", cards));
        sb.AppendLine();
        sb.AppendLine("        // effective[x]");
        var effPropNames = GetChoicePropNames("Observation", "Observation.effective[x]");
        if (_choices != null && _choices.TryGetValue("Observation", out var obsChoices) && obsChoices.TryGetValue("Observation.effective[x]", out var effCodes) && effPropNames.Count > 0)
        {
            foreach (var code in effCodes)
            {
                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                var propName = ChoiceNameMapper.ToChoicePropertyName("Observation.effective[x]", suffix);
                var csType = TypeMapService.Map(code);
                sb.AppendLine("        " + e.EmitChoiceWithMutex("Observation.effective[x]", csType, propName, cards, effPropNames));
            }
        }
        sb.AppendLine();
        sb.AppendLine("        " + e.EmitClr("Observation.issued", "FhirInstant", "Issued", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.performer", "ReferenceType", "Performer", cards));
        sb.AppendLine();
        sb.AppendLine("        // value[x]");
        var valPropNames = GetChoicePropNames("Observation", "Observation.value[x]");
        if (_choices != null && _choices.TryGetValue("Observation", out var obsChoices2) && obsChoices2.TryGetValue("Observation.value[x]", out var valCodes) && valPropNames.Count > 0)
        {
            foreach (var code in valCodes)
            {
                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                var propName = ChoiceNameMapper.ToChoicePropertyName("Observation.value[x]", suffix);
                var csType = TypeMapService.Map(code);
                sb.AppendLine("        " + e.EmitChoiceWithMutex("Observation.value[x]", csType, propName, cards, valPropNames));
            }
        }
        sb.AppendLine();
        sb.AppendLine("        // Facade Choice for effective[x] (Phase A, JsonIgnore)");
        sb.AppendLine("        [System.Text.Json.Serialization.JsonIgnore]");
        sb.AppendLine("        public ObservationEffectiveChoice? Effective { get { if (EffectiveDateTime != null) return new ObservationEffectiveChoice { DateTime = EffectiveDateTime }; if (EffectivePeriod != null) return new ObservationEffectiveChoice { Period = EffectivePeriod }; if (EffectiveTiming != null) return new ObservationEffectiveChoice { Timing = EffectiveTiming }; if (EffectiveInstant != null) return new ObservationEffectiveChoice { Instant = EffectiveInstant }; return null; } set { if (value == null) { EffectiveDateTime = null; EffectivePeriod = null; EffectiveTiming = null; EffectiveInstant = null; } else if (value.DateTime != null) { EffectiveDateTime = value.DateTime; } else if (value.Period != null) { EffectivePeriod = value.Period; } else if (value.Timing != null) { EffectiveTiming = value.Timing; } else if (value.Instant != null) { EffectiveInstant = value.Instant; } } }");
        sb.AppendLine();
        sb.AppendLine("        public sealed class ObservationEffectiveChoice");
        sb.AppendLine("        {");
        sb.AppendLine("            public FhirDateTime? DateTime { get; init; }");
        sb.AppendLine("            public Period? Period { get; init; }");
        sb.AppendLine("            public Timing? Timing { get; init; }");
        sb.AppendLine("            public FhirInstant? Instant { get; init; }");
        sb.AppendLine("            public static ObservationEffectiveChoice FromDateTime(FhirDateTime v) => new ObservationEffectiveChoice { DateTime = v };");
        sb.AppendLine("            public static ObservationEffectiveChoice FromPeriod(Period v) => new ObservationEffectiveChoice { Period = v };");
        sb.AppendLine("            public static ObservationEffectiveChoice FromTiming(Timing v) => new ObservationEffectiveChoice { Timing = v };");
        sb.AppendLine("            public static ObservationEffectiveChoice FromInstant(FhirInstant v) => new ObservationEffectiveChoice { Instant = v };");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        " + e.EmitClr("Observation.dataAbsentReason", "CodeableConcept", "DataAbsentReason", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.interpretation", "CodeableConcept", "Interpretation", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.note", "Annotation", "Note", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.bodySite", "CodeableConcept", "BodySite", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.method", "CodeableConcept", "Method", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.specimen", "ReferenceType", "Specimen", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.device", "ReferenceType", "Device", cards));
        sb.AppendLine();
        sb.AppendLine("        " + e.EmitClr("Observation.referenceRange", "Observation_ReferenceRange", "ReferenceRange", cards));
        sb.AppendLine("        " + e.EmitClr("Observation.component", "Observation_Component", "Component", cards));
        sb.AppendLine();
        sb.AppendLine("        public partial class Observation_ReferenceRange : BackboneElement<Observation_ReferenceRange>");
        sb.AppendLine("        {");
        sb.AppendLine("            public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"ReferenceRange\" : \"referenceRange\";");
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.referenceRange.low", "Quantity", "Low", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.referenceRange.high", "Quantity", "High", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.referenceRange.type", "CodeableConcept", "Type", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.referenceRange.appliesTo", "CodeableConcept", "AppliesTo", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.referenceRange.age", "DataTypeServices.DataTypes.ComplexTypes.Range", "Age", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.referenceRange.text", "FhirString", "Text", cards));
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public partial class Observation_Component : BackboneElement<Observation_Component>");
        sb.AppendLine("        {");
        sb.AppendLine("            public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"Component\" : \"component\";");
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.component.code", "CodeableConcept", "Code", cards));
        sb.AppendLine("            // value[x]");
        var compValPropNames = GetChoicePropNames("Observation", "Observation.component.value[x]");
        if (_choices != null && _choices.TryGetValue("Observation", out var obsChoices3) && obsChoices3.TryGetValue("Observation.component.value[x]", out var compValCodes) && compValPropNames.Count > 0)
        {
            foreach (var code in compValCodes)
            {
                var suffix = ChoiceNameMapper.ToPropertySuffix(code);
                var propName = ChoiceNameMapper.ToChoicePropertyName("Observation.component.value[x]", suffix);
                var csType = TypeMapService.Map(code);
                sb.AppendLine("            " + e.EmitChoiceWithMutexBackbone("Observation.component.value[x]", csType, propName, cards, compValPropNames));
            }
        }
        sb.AppendLine();
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.component.dataAbsentReason", "CodeableConcept", "DataAbsentReason", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.component.interpretation", "CodeableConcept", "Interpretation", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Observation.component.referenceRange", "Observation_ReferenceRange", "ReferenceRange", cards));
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public string BuildOrganization(string ns, IReadOnlyDictionary<string, Cardinality> cards)
    {
        var e = _emitter;
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using DataTypeServices.DataTypes.PrimitiveTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.ComplexTypes;");
        sb.AppendLine("using DataTypeServices.DataTypes.SpecialTypes;");
        sb.AppendLine("using System.Text.Json.Nodes;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using FhirCore.Base;");
        sb.AppendLine("using DataTypeServices.TypeFramework;");
        sb.AppendLine("using DataTypeServices.DataTypes.MetaTypes;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine("    public partial class Organization : ResourceBase");
        sb.AppendLine("    {");
        sb.AppendLine("        public override string ResourceType => \"Organization\";");
        sb.AppendLine();
        sb.AppendLine("        public Organization() { }");
        sb.AppendLine("        public Organization(string json) { SetRawFrom(JsonNode.Parse(json)); }");
        sb.AppendLine("        public Organization(JsonNode? source) { SetRawFrom(source); }");
        sb.AppendLine("        // JSON handled by ResourceBase.UpdateRaw via OnPropertyChanged");
        sb.AppendLine();
        sb.AppendLine("        " + e.EmitClr("Organization.identifier", "Identifier", "Identifier", cards));
        sb.AppendLine("        " + e.EmitClr("Organization.active", "FhirBoolean", "Active", cards));
        sb.AppendLine("        " + e.EmitClr("Organization.type", "CodeableConcept", "Type", cards));
        sb.AppendLine("        " + e.EmitClr("Organization.name", "FhirString", "Name", cards));
        sb.AppendLine("        " + e.EmitClr("Organization.alias", "FhirString", "Alias", cards));
        sb.AppendLine("        " + e.EmitClr("Organization.telecom", "ContactPoint", "Telecom", cards));
        sb.AppendLine("        " + e.EmitClr("Organization.address", "Address", "Address", cards));
        sb.AppendLine("        " + e.EmitClr("Organization.partOf", "ReferenceType", "PartOf", cards));


        sb.AppendLine();
        sb.AppendLine("        " + e.EmitClr("Organization.contact", "Organization_Contact", "Contact", cards));
        sb.AppendLine();
        sb.AppendLine("        public partial class Organization_Contact : BackboneElement<Organization_Contact>");
        sb.AppendLine("        {");
        sb.AppendLine("            public override string GetFhirTypeName(bool withCapital = true) => withCapital ? \"Contact\" : \"contact\";");
        sb.AppendLine("            " + e.EmitClrBackbone("Organization.contact.purpose", "CodeableConcept", "Purpose", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Organization.contact.name", "HumanName", "Name", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Organization.contact.telecom", "ContactPoint", "Telecom", cards));
        sb.AppendLine("            " + e.EmitClrBackbone("Organization.contact.address", "Address", "Address", cards));
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }
}
