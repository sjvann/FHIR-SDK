## 目的
以「生成器（CodeGen）」統一產生 R4 與 R5 的 Resource 程式碼，最大程度維持 API 穩定、IntelliSense 友好，並隔離不同版本改動，最終讓全部 Resource 以生成為主、手寫為輔。

---

## 背景與挑戰
- 目標：
  - 提供 HL7 FHIR App 開發者一個具 IntelliSense、Delegate、匿名函數、泛型友好的 C# SDK。
  - 將 Domain Model 迅速轉換為符合 FHIR 規範的內容，支援 JSON 與 XML。
  - 面對多版本（R4、R5…持續演進）變化，前端不受破壞；宣告版本後即可獲得完整支援。
- 現況與痛點：
  - 已有 R5 為基礎的架構；導入 R4 不希望推倒重來。
  - Type Framework 資料型態極度複雜（Choice [x]、Reference 多目標、交互參照、循環繼承）。
  - AI 難以一次性處理所有型別細節，需要明確「手寫基底 + 生成資源」的拆分策略。

---

## 設計原則
1) 安全隔離：R4 與 R5 生成輸出分目錄，不覆蓋既有手寫檔；以 .g.cs 與檔頭 checksum/標記自動檔案。
2) 單一真實來源（SSOT）：支援資源清單、版本映射與註冊，皆由 CodeGen 產出並被 SDK 使用。
3) 手寫最小化：
   - Type Framework（基底型別）手寫且穩定演進。
   - Resource 類別以生成為主，保留 partial class 讓手寫擴充（選配）。
4) 先簡後繁：優先 JSON；XML 第二階段；Choice/Reference 先以保守模型實作，隨後漸進增強。
5) 可回溯、可比對：生成器提供 dry-run、diff 檢視與變更摘要。

---

## 目錄與模組
- definition/<Version>/...：HL7 官方 StructureDefinition（或 Profile/ImplementationGuide）來源檔（JSON/XML），由使用者提供。
- tools/CodeGen/：C# Console 專案，讀取 definition，輸出程式碼。
- FhirCore/TypeFramework/：手寫的 FHIR 資料型別（primitive/常用 complex）。
- ResourceTypeServices/
  - R5/Generated/*.g.cs
  - R5/Partial/*.cs（選配：手寫擴充）
  - R4/Generated/*.g.cs
  - R4/Partial/*.cs（選配：手寫擴充）
- FhirCore/Versioning/
  - ResourceRegistry.<Version>.g.cs（CodeGen 產生，作為 SSOT）

---

## 生成流程（Pipeline）
1) 掃描輸入
   - 輸入：definition/<Version>（R4 或 R5）
   - 驗證：檔案完整度/必要欄位；版本代號與對應規格對齊。
2) 解析 StructureDefinition
   - 建立中繼結構（中介模型）：Resource、Element、Binding、Cardinality、Reference 目標、Choice [x] 清單。
3) 型別映射（Type Mapping）
   - 將 FHIR 型別（primitive/complex）映射至 Type Framework。
   - 無對應型別者先映射為 Element/BackboneElement 保底型別，後續逐步擴充。
4) 程式碼生成
   - Resource 類別（partial class + .g.cs）：
     - 屬性、註釋（XML Doc）、必要屬性標記。
     - Choice [x] 與 Reference 的序列化/驗證欄位。
   - 版本註冊（ResourceRegistry.<Version>.g.cs）：
     - 支援資源清單、建構工廠、驗證入口、ResourceType->Class 映射。
5) 安全護欄
   - 僅在 ResourceTypeServices/<Version>/Generated/ 下寫檔。
   - .g.cs 檔頭含「Auto-Generated」「Do Not Edit」「Checksum」。
   - dry-run 模式預設開啟；需帶明確旗標才覆寫。

---

## Type Framework（手寫，逐步擴充）
- Primitive：boolean, integer, decimal, string, uri, code, date, dateTime, instant, markdown, oid, id, unsignedInt, positiveInt 等。
- 常用 Complex：CodeableConcept, Coding, Reference, Identifier, Period, HumanName, Address, Quantity, Range, Ratio, Annotation, Narrative, Meta。
- Choice [x] 建模（第一階段）：
  - 生成多個強型別屬性（如 ValueString、ValueQuantity…），保證「最多一個」被設定；驗證時檢查互斥。
  - 之後可升級為 Choice<T1,T2,...> 輕量 union（不引入外部套件）。
- Reference 建模：
  - Reference<TResource> 泛型包裝；多目標時以 [ReferenceTargets] 屬性標註允許集合（由生成產生），執行期驗證。

---

## JSON 與 XML
- JSON：第一階段以 System.Text.Json；保留命名策略/屬性名稱與 FHIR JSON 一致（需處理 value[x] 名稱規則）。
- XML：第二階段加入 DataContractSerializer 或自訂序列化管線；由生成器附帶必要屬性。

---

## IntelliSense 與泛型/委派體驗
- Fluent Builder/Factory
  - FhirSDK.Create<T>(version).With(...).Build();
  - 以委派/匿名函數配置複合屬性（如 CodeableConcept、HumanName）。
- 驗證：FhirSDK.Validate(resource, version)；或 resource.Validate()（版本感知）。

示例（簡化）：
```csharp
var obs = FhirSDK.Create<Observation>("R4", o =>
{
    o.Status = "final";
    o.Code = CodeableConcept.From("http://loinc.org", "1234-5", "Glucose");
    o.ValueQuantity = new Quantity(5.6m, "mmol/L");
});
```

---

## 生成輸出策略
- 產出檔名：{ResourceName}.g.cs；同名 partial class 可存在於 Partial/ 供手寫擴充。
- 產出內容：
  - XML Doc 來自 StructureDefinition 與 Binding
  - [Required]/Cardinality 對應的驗證屬性/方法
  - [ReferenceTargets(...)] 與 Choice 欄位互斥檢查
- 版本註冊輸出：ResourceRegistry.<Version>.g.cs 作為 SSOT，供 VersionManager 使用。

---

## 不互相破壞的保障
- 兩個輸出根：ResourceTypeServices/R5/Generated 與 ResourceTypeServices/R4/Generated。
- 生成器的 --targetVersion 與 --outputRoot 必填；路徑白名單限制。
- dry-run 預覽清單 + 編譯測試全綠才允許覆寫（可用旗標跳過，但預設不允許）。
- .g.cs 僅能由生成器寫入；若檔頭 checksum 不符，生成器先中止並報告。

---

## 漸進計畫（建議 8–10 週）
1) M0：基線
   - 確認 definition/<Version> 資料來源與格式；提交到 repo。
   - 設置工程規範（Analyzer/StyleCop、Nullable、CI 基礎）。
2) M1：CodeGen PoC
   - 解析 2–3 個代表性 Resource（如 Patient、Observation、Organization）。
   - 產生到 R4/Generated 與 R5/Generated，且不影響現有手寫。
   - 建立 ResourceRegistry.<Version>.g.cs 與 SSOT 對齊。
3) M2：擴充與驗證
   - R5 第一批 30–50 個資源；R4 同步 20–30 個。
   - 加入 Choice/Reference 驗證邏輯；完善 JSON 命名規則。
4) M3：覆蓋 60–70%
   - 第二批 50–70 個資源；引入快取/效能基準。
5) M4：覆蓋 ~100%
   - DocFX 自動化導出；回歸測試齊備；準備將現有 R5 手寫切換為生成版。
6) M5：R4 最小可用
   - 與 VersionManager 完整整合；規劃 R6 模板。

---

## 需要您的決策
- 定義來源：請確認 definition/<Version> 放置位置與格式（JSON/ZIP/XML）。
- Choice 策略：
  - A 方案：多型別屬性（ValueString/ValueQuantity…）+ 互斥驗證（較直觀，IDE 友好）。
  - B 方案：Choice<T1,...> union 型別（型別更嚴謹，成本較高）。
- JSON/XML 優先順序：是否先 JSON，待穩定再上 XML？
- 分支命名與流：是否使用 feature/unified-codegen-r4-r5 作為分支名稱？

---

## 我方承諾與風險控管
- 不改動現有手寫 R5；所有生成物進入 Generated/
- 以乾跑（dry-run）+ CI 驗證為前置，避免誤覆寫。
- Type Framework 僅逐步擴充常見 complex 型別；其餘先以 Element 保底。
- Reference 目標集合、Choice 欄位互斥，皆由生成器自動產出與驗證。

---

## 後續動作建議
- 您確認上列決策後：
  1) 我將建立分支 feature/unified-codegen-r4-r5（僅本地，不推遠端，待 PR 再推）。
  2) 提交 tools/CodeGen 腳手架與最小 PoC。
  3) 將 SSOT（ResourceRegistry）導入 FhirVersionManager。

---

## 備註
- 目前 repo 中未發現 definition/ 目錄；請提供或指示正確路徑，以便啟動 PoC。

