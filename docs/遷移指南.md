# FHIR SDK 遷移指南

## 概述

本指南將協助您從舊的 FhirVersionManager 架構遷移到新的版本特定套件架構。新架構提供更好的 IntelliSense 支援、編譯時期類型安全和更清晰的版本管理。

## ?? 重要變更

### 舊架構的問題
- **類型衝突**：不同版本的相同資源可能產生命名衝突
- **IntelliSense 不準確**：IDE 無法提供精確的版本特定 API 提示
- **執行時期錯誤**：版本選擇在執行時期處理，容易出錯
- **複雜的版本管理**：需要複雜的類型映射機制

### 新架構的優勢
- **編譯時期版本確定**：通過 NuGet 套件選擇版本
- **完整 IntelliSense 支援**：IDE 提供精確的版本特定 API
- **類型安全**：避免版本間的類型衝突
- **簡化部署**：只需部署需要的版本

## 遷移步驟

### 第一步：更新套件參考

#### 舊方式
```xml
<!-- 舊的套件參考 -->
<PackageReference Include="ResourceTypeServices" Version="1.0.0" />
<PackageReference Include="FhirCore" Version="1.0.0" />
```

#### 新方式
```xml
<!-- 新的套件參考 - 選擇需要的版本 -->

<!-- 只需要 R5 支援 -->
<PackageReference Include="FhirCore.R5" Version="1.0.0" />

<!-- 只需要 R4 支援 -->
<PackageReference Include="FhirCore.R4" Version="1.0.0" />

<!-- 需要同時支援 R4 和 R5 -->
<PackageReference Include="FhirCore.R4" Version="1.0.0" />
<PackageReference Include="FhirCore.R5" Version="1.0.0" />
```

### 第二步：更新 using 陳述式

#### 舊方式
```csharp
using FhirCore.Versioning;
using ResourceTypeServices.R5;
using FhirCore.SDK;
```

#### 新方式
```csharp
// R5 專案
using FhirCore.R5.Resources;
using FhirCore.R5.Extensions;

// R4 專案
using FhirCore.R4.Resources;
using FhirCore.R4.Extensions;

// 多版本專案
using R4 = FhirCore.R4.Resources;
using R5 = FhirCore.R5.Resources;
```

### 第三步：更新資源建立方式

#### 舊方式
```csharp
// 使用版本管理器
FhirSDK.SetVersion("R5");
var patient = FhirSDK.CreateResource<Patient>();

// 或者
var versionManager = new FhirVersionManager();
versionManager.SwitchVersion("R5");
var patient = versionManager.GetCurrentVersionResource<Patient>();
```

#### 新方式
```csharp
// R5 版本 - 直接建立
using FhirCore.R5.Resources;

var patient = new Patient();

// 或使用工廠模式
using FhirCore.Factory;

var patient = FhirFactory.R5.CreatePatient();

// 多版本支援
using R4 = FhirCore.R4.Resources;
using R5 = FhirCore.R5.Resources;

var r4Patient = new R4.Patient();
var r5Patient = new R5.Patient();
```

### 第四步：更新驗證方式

#### 舊方式
```csharp
var versionManager = new FhirVersionManager();
var result = versionManager.ValidateResource(patient, "R5");
```

#### 新方式
```csharp
// 直接使用資源的驗證方法
var result = patient.Validate();

// 或使用版本特定的驗證器
using FhirCore.R5.Validation;

var validator = new R5Validator();
var result = validator.Validate(patient);
```

## 常見遷移情境

### 情境 1：單一版本專案

如果您的專案只使用一個 FHIR 版本：

```csharp
// 專案檔案
<PackageReference Include="FhirCore.R5" Version="1.0.0" />

// 程式碼
using FhirCore.R5.Resources;
using FhirCore.R5.Extensions;

public class PatientService
{
    public Patient CreatePatient(string given, string family)
    {
        return new Patient()
            .WithName(given, family)
            .WithGender(GenderCodes.Unknown);
    }
    
    public bool ValidatePatient(Patient patient)
    {
        var result = patient.Validate();
        return result.IsValid;
    }
}
```

### 情境 2：多版本支援專案

如果您的專案需要同時支援多個版本：

```csharp
// 專案檔案
<PackageReference Include="FhirCore.R4" Version="1.0.0" />
<PackageReference Include="FhirCore.R5" Version="1.0.0" />

// 程式碼
using R4 = FhirCore.R4.Resources;
using R5 = FhirCore.R5.Resources;

public class MultiVersionPatientService
{
    public R4.Patient CreateR4Patient(string given, string family)
    {
        return new R4.Patient
        {
            Name = new List<HumanName>
            {
                new HumanName
                {
                    Given = new List<FhirString> { new(given) },
                    Family = new FhirString(family)
                }
            }
        };
    }
    
    public R5.Patient CreateR5Patient(string given, string family)
    {
        return new R5.Patient
        {
            Name = new List<HumanName>
            {
                new HumanName
                {
                    Given = new List<FhirString> { new(given) },
                    Family = new FhirString(family)
                }
            }
        };
    }
    
    // 版本間轉換
    public R5.Patient ConvertToR5(R4.Patient r4Patient)
    {
        return FhirCore.Tools.Migration.VersionMigrator.MigrateToR5(r4Patient);
    }
}
```

### 情境 3：條件式版本選擇

如果您需要根據條件選擇版本：

```csharp
using FhirCore.Factory;

public class ConditionalVersionService
{
    public object CreatePatient(string version, string given, string family)
    {
        return version.ToUpper() switch
        {
            "R4" => FhirFactory.R4.CreatePatient()
                .WithName(given, family),
            "R5" => FhirFactory.R5.CreatePatient()
                .WithName(given, family),
            _ => throw new NotSupportedException($"版本 {version} 不支援")
        };
    }
}
```

## 版本差異處理

### 性別欄位的變更

R4 和 R5 在某些欄位上有所不同，例如 Patient.Gender：

```csharp
// R4 - 使用 FhirCode
using R4 = FhirCore.R4.Resources;

var r4Patient = new R4.Patient
{
    Gender = new FhirCode("male")
};

// R5 - 使用 CodeableConcept  
using R5 = FhirCore.R5.Resources;

var r5Patient = new R5.Patient
{
    Gender = new CodeableConcept
    {
        Coding = new List<Coding>
        {
            new Coding
            {
                System = new FhirUri("http://hl7.org/fhir/administrative-gender"),
                Code = new FhirCode("male"),
                Display = new FhirString("Male")
            }
        }
    }
};
```

### 新資源的支援

R5 引入了新的資源類型：

```csharp
// 只在 R5 中可用
using FhirCore.R5.Resources;

var evidenceReport = new EvidenceReport
{
    Status = new FhirCode("active"),
    Subject = new ReferenceType { Reference = "Patient/example" }
};
```

## 效能最佳化

### 減少記憶體使用

新架構只載入需要的版本：

```csharp
// 舊方式 - 載入所有版本
var versionManager = new FhirVersionManager(); // 載入 R4, R5, R6

// 新方式 - 只載入需要的版本
using FhirCore.R5.Resources; // 只載入 R5
```

### 編譯時期最佳化

編譯器可以執行更好的最佳化：

```csharp
// 編譯器知道確切的類型
var patient = new FhirCore.R5.Resources.Patient();
// vs 執行時期類型解析
var patient = versionManager.GetResource<Patient>("R5");
```

## 測試遷移

### 更新單元測試

```csharp
// 舊測試
[Test]
public void TestPatientCreation()
{
    FhirSDK.SetVersion("R5");
    var patient = FhirSDK.CreateResource<Patient>();
    Assert.IsNotNull(patient);
}

// 新測試
[Test]
public void TestR5PatientCreation()
{
    var patient = new FhirCore.R5.Resources.Patient();
    Assert.IsNotNull(patient);
    Assert.AreEqual("Patient", patient.ResourceType);
}

[Test]
public void TestR4PatientCreation()
{
    var patient = new FhirCore.R4.Resources.Patient();
    Assert.IsNotNull(patient);
    Assert.AreEqual("Patient", patient.ResourceType);
}
```

## 常見問題解答

### Q: 是否可以在同一個專案中混用舊架構和新架構？

A: 技術上可行，但不建議。建議完整遷移到新架構以獲得最佳體驗。

### Q: 如何處理現有的序列化程式碼？

A: 新架構保持相同的序列化介面，現有程式碼應該可以正常運作。

### Q: 效能是否會有影響？

A: 新架構效能更好，因為減少了執行時期的類型解析和版本檢查。

### Q: 如何確保團隊成員使用正確的版本？

A: 通過專案檔案的套件參考來強制使用正確的版本，編譯時期會檢查相容性。

## 進階主題

### 自訂驗證器

```csharp
// 為特定版本建立自訂驗證器
public class CustomR5Validator : FhirCore.R5.Validation.R5Validator
{
    public override ValidationResult ValidatePatient(Patient patient)
    {
        var baseResult = base.ValidatePatient(patient);
        
        // 加入自訂驗證邏輯
        if (patient.Name?.Any() != true)
        {
            return ValidationResult.Error("患者必須有姓名", "Name");
        }
        
        return baseResult;
    }
}
```

### 版本間轉換工具

```csharp
// 建立轉換工具
public static class VersionConverter
{
    public static FhirCore.R5.Resources.Patient ToR5(
        FhirCore.R4.Resources.Patient r4Patient)
    {
        return new FhirCore.R5.Resources.Patient
        {
            Id = r4Patient.Id,
            Name = r4Patient.Name,
            // 處理性別欄位的轉換
            Gender = ConvertGender(r4Patient.Gender),
            BirthDate = r4Patient.BirthDate
        };
    }
    
    private static CodeableConcept? ConvertGender(FhirCode? gender)
    {
        if (gender?.Value == null) return null;
        
        return new CodeableConcept
        {
            Coding = new List<Coding>
            {
                new Coding
                {
                    System = new FhirUri("http://hl7.org/fhir/administrative-gender"),
                    Code = new FhirCode(gender.Value),
                    Display = new FhirString(GetGenderDisplay(gender.Value))
                }
            }
        };
    }
}
```

## 總結

新的版本特定套件架構提供了：

1. **更好的開發體驗** - 完整的 IntelliSense 支援
2. **編譯時期安全** - 避免版本相關的執行時期錯誤
3. **更清晰的架構** - 版本通過套件選擇確定
4. **更好的效能** - 減少執行時期的版本檢查
5. **簡化的部署** - 只需部署需要的版本

遷移過程可能需要一些時間，但長期來看將大大改善開發和維護體驗。建議採用漸進式遷移策略，先從新功能開始使用新架構，然後逐步遷移現有程式碼。